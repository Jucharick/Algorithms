// Дерево – это структура данных, эмулирующая древовидную структуру в виде
// набора связанных узлов. Дерево является частным случае графа, в котором
// отсутствуют циклические связи. Дерево состоит из узлов, связанных между собой
// ребрами по принципу родитель-ребенок.

// Один узел может содержать в себе любое количество детей, но у любого ребенка
// может быть только один родитель. Самый верхний узел, не имеющий родителя,
// называется корнем дерева, а узлы, не имеющие детей – листьями.

// Алгоритмы обхода дерева:

// 1. Обход в глубину
// Это рекурсивный
// подход к перебору всех значений в дереве, построенный на вызове всех доступных
// детей для каждого узла. Таким образом максимальная глубина рекурсии будет
// равна максимальной глубине дерева, а порядок будет идти сверху-вниз и
// слева-направо.

// 2. Обход в ширину
// Обход в ширину предполагает, что мы не обрабатываем детей до тех пор, пока все
// родителя одного уровня не были обработаны.
// Данный алгоритм не вызывает рекурсию, но в основном используется не для
// поиска, а для массовых операций со значениями в дереве.
// Минус - необходимо помнить о всех элементах на указанном уровне - необходимо создать в памяти некий объект, в котором 
// будут ссылки на все текущие ноды и будущие ноды (сохранение чаилдов)

// Бинарное дерево
// Бинарным деревом называют частный случай дерева, где все элементы
// обязательно строго уникальны, каждый родитель имеет не более 2 детей, при этом
// левый ребенок всегда меньше родителя, а правый – больше.

// Сбалансированное дерево
// Сбалансированным деревом называют частный случай бинарного дерева, у
// которого выполняется следующее требование: для любого узла дерева высота его
// правого поддерева отличается от высоты левого поддерева не более чем на
// единицу.
// Таким образом, сбалансированное дерево дает нам идеальную структуру для
// бинарного поиска – корень такого дерева — это его центральный элемент –
// количество элементов справа и слева от него различается не более чем на
// единицу, что характерно для выбора стартовой позиции в бинарном поиске. Таким
// образом, сложность поиска по сбалансированному дереву составляет O(log n), что
// дает очень высокую производительность.

// Для поддержания свойства сбалансированности в процессе операций добавления
// или удаления элементов такие деревья должны проводить операции балансировки,
// чтобы не допустить разбалансированности и ухудшения сложности поиска.
// Существуют различные типы сбалансированных деревьев – АВЛ-дерево,
// красно-черное дерево, 2-3 дерево и т.д. Каждое из которых имеет собственные
// алгоритмы балансировки. Так, например, для балансировки АВЛ-дерева каждая
// нода помимо информации о значении и детях, так же хранит показатель глубины,
// на основе которого проводится балансировка по специальному алгоритму. А у
// красно-черного дерева вместо показателя глубины используется показатель цвета
// – ноды могут быть либо черными, либо красными.
// Использование сбалансированных деревьев позволяет создать динамическую
// самоддерживаемую структуру, имеющую очень высокую скорость поиска
// элементов.

// Красно - черное дерево
// - каждый узел можнет быть либо черным либо красным и иметь двух потомков
// - корень всегда черный
// - дети красного узла всегда черные

// Левостороннее красно - черное дерево
// - красный узел может быть только левым потомком

package Lec_4;

import java.util.ArrayList;
import java.util.List;

public class Simple_tree {
  private Node root; // начало дерева, откуда идет расчет

  public boolean containsDepth (int value) {
    if (root != null) {
      Node node = containsDepth (value, root);
      if (node != null) {
        return true;
      }
    }
    return false;
  }

  // 1. Обход в глубину
  private Node containsDepth (int value, Node node) {
    if (node.value == value) {
      return node;
    } else {
      for (Node child: node.children) {
        Node result = containsDepth (value, child);
        if (result != null) {
          return result;
        }
      }
    }
    return null;
  }

  // 2. Обход в ширину
  private Node containsWiddth (int value) {
    List<Node> line = new ArrayList<>();
    line.add(root);
    while (line.size() > 0) {
      List<Node> nextLine = new ArrayList<>();
      for (Node node: line) {
        if (node.value == value) {
          return node;
        }
        nextLine.addAll(node.children);
      }
      line = nextLine;
    }
    return null;
  }

  private class Node {
    private int value;
    private List <Node> children;
  }
}
